DESCRIPTION:
Package: ggbeeswarm
Type: Package
Title: Categorical Scatter (Violin Point) Plots
Version: 0.7.3
Date: 2025-11-28
Authors@R: c(
    person(given="Erik", family="Clarke", role=c("aut", "cre"), email="erikclarke@gmail.com"),
    person(given="Scott", family="Sherrill-Mix", role=c("aut"), email="sherrillmix@gmail.com"),
    person(given="Charlotte", family="Dawson", role=c("aut"), email="csdaw@outlook.com"))
Description: Provides two methods of plotting categorical scatter plots such
    that the arrangement of points within a category reflects the density of
    data at that region, and avoids over-plotting.
URL: https://github.com/eclarke/ggbeeswarm
BugReports: https://github.com/eclarke/ggbeeswarm/issues
Encoding: UTF-8
License: GPL (>= 3)
Depends: R (>= 3.5.0), ggplot2 (>= 3.3.0)
Imports: beeswarm, lifecycle, vipor, cli
Suggests: gridExtra
RoxygenNote: 7.3.3
NeedsCompilation: no
Packaged: 2025-11-29 00:53:34 UTC; erik
Author: Erik Clarke [aut, cre],
  Scott Sherrill-Mix [aut],
  Charlotte Dawson [aut]
Maintainer: Erik Clarke <erikclarke@gmail.com>
Repository: CRAN
Date/Publication: 2025-11-29 06:10:25 UTC
Built: R 4.4.1; ; 2026-02-12 15:24:07 UTC; unix

--------------------------------------------------------------------------------
Function: geom_beeswarm()
Points, jittered to reduce overplotting using the beeswarm package

Description:

     The beeswarm geom is a convenient means to offset points within
     categories to reduce overplotting. Uses the beeswarm package.

Usage:

     geom_beeswarm(
       mapping = NULL,
       data = NULL,
       stat = "identity",
       ...,
       method = "swarm",
       cex = 1,
       side = 0L,
       priority = "ascending",
       fast = TRUE,
       dodge.width = NULL,
       corral = "none",
       corral.width = 0.9,
       preserve.data.axis = FALSE,
       groupOnX = NULL,
       orientation = NULL,
       beeswarmArgs = list(),
       na.rm = FALSE,
       show.legend = NA,
       inherit.aes = TRUE
     )
     
Arguments:

 mapping: Set of aesthetic mappings created by ‘aes’ or ‘aes_’. If
          specified and ‘inherit.aes = TRUE’ (the default), is combined
          with the default mapping at the top level of the plot. You
          only need to supply ‘mapping’ if there isn't a mapping
          defined for the plot.

    data: A data frame. If specified, overrides the default data frame
          defined at the top level of the plot.

    stat: The statistical transformation to use on the data for this
          layer, as a string.

     ...: other arguments passed to ggplot2::layer ‘params’ argument.

  method: Method for arranging points. Options are ‘"swarm"’ (default),
          ‘"compactswarm"’, ‘"square"’, ‘"hex"’, and ‘"center"’. See
          Details below.

     cex: Scaling for adjusting point spacing (see
          ‘beeswarm::swarmx()’). Values between 1 (default) and 3 tend
          to work best.

    side: Direction to perform jittering: 0: both directions; 1: to the
          right or upwards; -1: to the left or downwards.

priority: Method used to perform point layout. Options are
          ‘"ascending"’ (default), ‘"descending"’, ‘"density"’,
          ‘"random"’, or ‘"none"’. See Details below.

    fast: If ‘TRUE’ (default), use compiled version of swarm algorithm.
          This option is ignored for all methods except ‘"swarm"’ and
          ‘"compactswarm"’.

dodge.width: Amount by which points from different aesthetic groups
          will be dodged. This requires that one of the aesthetics is a
          factor.

  corral: Method used to adjust points that would be placed too wide
          horizontally. Options are ‘"none"’ (default), ‘"gutter"’,
          ‘"wrap"’, ‘"random"’, and ‘"omit"’. See Details below.

corral.width: Width of the corral, if not ‘"none"’. Default is ‘0.9’.

preserve.data.axis: If TRUE, prevent ‘method’ from modifying the data
          axis (default FALSE). See Details for more info.

groupOnX: *[Superseded]* See ‘orientation’.

orientation: The orientation (i.e., which axis to group on) is inferred
          from the data. This can be overridden by setting
          ‘orientation’ to either ‘"x"’ or ‘"y"’.

beeswarmArgs: *[Deprecated]* No longer used.

   na.rm: If ‘FALSE’, the default, missing values are removed with a
          warning. If ‘TRUE’, missing values are silently removed.

show.legend: logical. Should this layer be included in the legends?
          ‘NA’, the default, includes if any aesthetics are mapped.
          ‘FALSE’ never includes, and ‘TRUE’ always includes.

inherit.aes: If ‘FALSE’, overrides the default aesthetics, rather than
          combining with them. This is most useful for helper functions
          that define both data and aesthetics and shouldn't inherit
          behaviour from the default plot specification, e.g.
          ‘borders’.

Details:

     *method:* specifies the algorithm used to avoid overlapping
     points. The default ‘"swarm"’ method places points in increasing
     order. If a point would overlap with an existing point, it is
     shifted sideways (along the group axis) by a minimal amount
     sufficient to avoid overlap.

     While the ‘"swarm"’ method places points in a predetermined order,
     the ‘"compactswarm"’ method uses a greedy strategy to determine
     which point will be placed next. This often leads to a more
     tightly-packed layout. The strategy is very simple: on each
     iteration, a point that can be placed as close as possible to the
     non-data axis is chosen and placed. If there are two or more
     equally good points, ‘priority’ is used to break ties.

     The other 3 methods first discretise the values along the data
     axis, in order to create more efficient packing. The ‘"square"’
     method places points on a square grid, whereas ‘"hex"’ uses a
     hexagonal grid. ‘"centre"’/‘"center"’ uses a square grid to
     produce a symmetric swarm. The number of break points for
     discretisation is determined by a combination of the available
     plotting area and the ‘cex’ argument.

     *priority:* controls the order in which points are placed, which
     generally has a noticeable effect on the plot appearance.
     ‘"ascending"’ gives the 'traditional' beeswarm plot.
     ‘"descending"’ is the opposite. ‘"density"’ prioritizes points
     with higher local density. ‘"random"’ places points in a random
     order. ‘"none"’ places points in the order provided.

     *corral:* By default, swarms from different groups are not
     prevented from overlapping, i.e. "corral = "none". Thus, datasets
     that are very large or unevenly distributed may produce ugly
     overlapping beeswarms. To control runaway points one can use the
     following methods. ‘"gutter"’ collects runaway points along the
     boundary between groups. ‘"wrap"’ implement periodic boundaries.
     ‘"random"’ places runaway points randomly in the region. ‘"omit"’
     omits runaway points.

     #' *preserve.data.axis:* In some cases, the underlying method may
     attempt to change the position of points along the ungrouped, or
     data, axis, in order to keep them from overlapping. To prevent
     this, set this option to TRUE.

See Also:

     ‘geom_quasirandom()’ an alternative method, ‘beeswarm::swarmx()’
     how spacing is determined, ‘ggplot2::geom_point()’ for regular,
     unjittered points, ‘ggplot2::geom_jitter()’ for jittered points,
     ‘ggplot2::geom_boxplot()’ for another way of looking at the
     conditional distribution of a variable

Examples:

       # Generate fake data
       distro <- data.frame(
         'variable'=rep(c('runif','rnorm'),each=100),
         'value'=c(runif(100, min=-3, max=3), rnorm(100))
       )
       ggplot2::ggplot(distro,ggplot2::aes(variable, value)) +
         geom_beeswarm(priority='density',size=2.5)
     

--------------------------------------------------------------------------------
Function: geom_quasirandom()
Points, jittered to reduce overplotting using the vipor package

Description:

     The quasirandom geom is a convenient means to offset points within
     categories to reduce overplotting. Uses the vipor package.

Usage:

     geom_quasirandom(
       mapping = NULL,
       data = NULL,
       stat = "identity",
       ...,
       method = "quasirandom",
       width = NULL,
       varwidth = FALSE,
       bandwidth = 0.5,
       nbins = NULL,
       dodge.width = NULL,
       groupOnX = NULL,
       orientation = NULL,
       na.rm = FALSE,
       show.legend = NA,
       inherit.aes = TRUE
     )
     
Arguments:

 mapping: Set of aesthetic mappings created by ‘aes’ or ‘aes_’. If
          specified and ‘inherit.aes = TRUE’ (the default), is combined
          with the default mapping at the top level of the plot. You
          only need to supply ‘mapping’ if there isn't a mapping
          defined for the plot.

    data: A data frame. If specified, overrides the default data frame
          defined at the top level of the plot.

    stat: The statistical transformation to use on the data for this
          layer, as a string.

     ...: other arguments passed to ggplot2::layer ‘params’ argument.

  method: Method used for distributing points. Options are
          ‘"quasirandom"’ (default), ‘"pseudorandom"’, ‘"smiley"’,
          ‘"maxout"’, ‘"frowney"’, ‘"minout"’, ‘"tukey"’,
          ‘"tukeyDense"’. See ‘vipor::offsetSingleGroup()’ for the
          details of each method.

   width: Maximum amount of spread (default: 0.4)

varwidth: Vary the width by the relative size of each group. (default:
          ‘FALSE’)

bandwidth: the bandwidth adjustment to use when calculating density
          Smaller numbers (< 1) produce a tighter "fit". (default: 0.5)

   nbins: the number of bins used when calculating density (has little
          effect with quasirandom/random distribution)

dodge.width: Amount by which points from different aesthetic groups
          will be dodged. This requires that one of the aesthetics is a
          factor. To disable dodging between groups, set this to NULL.
          (default: 0)

groupOnX: *[Superseded]* See ‘orientation’.

orientation: The orientation (i.e., which axis to group on) is inferred
          from the data. This can be overridden by setting
          ‘orientation’ to either ‘"x"’ or ‘"y"’.

   na.rm: if ‘FALSE’ (default), missing values are removed with a
          warning. If ‘TRUE’, missing values are silently removed.

show.legend: logical. Should this layer be included in the legends?
          ‘NA’, the default, includes if any aesthetics are mapped.
          ‘FALSE’ never includes, and ‘TRUE’ always includes.

inherit.aes: If ‘FALSE’, overrides the default aesthetics, rather than
          combining with them. This is most useful for helper functions
          that define both data and aesthetics and shouldn't inherit
          behaviour from the default plot specification, e.g.
          ‘borders’.

See Also:

     ‘vipor::offsetSingleGroup()’ how spacing is determined,
     ‘ggplot2::geom_point()’ for regular, unjittered points,
     ‘ggplot2::geom_jitter()’ for jittered points,
     ‘ggplot2::geom_boxplot()’ for another way of looking at the
     conditional distribution of a variable

Examples:

       # Generate fake data
       distro <- data.frame(
         'variable'=rep(c('runif','rnorm'),each=100),
         'value'=c(runif(100, min=-3, max=3), rnorm(100))
       )
       ggplot2::ggplot(distro, ggplot2::aes(variable, value)) + 
       geom_quasirandom(width=0.1)
     

--------------------------------------------------------------------------------
Function: ggbeeswarm()
ggbeeswarm extends ggplot2 with violin point/beeswarm plots

Description:

     This package allows plotting of several groups of one dimensional
     data as a violin point/beeswarm plot in ggplot2 by arranging data
     points to resemble the underlying distribution. The development
     version of this package is on
     <https://github.com/eclarke/ggbeeswarm>.

Author(s):

     Erik Clarke, <mailto:erikclarke@gmail.com>

See Also:

     ‘position_quasirandom()’, ‘position_beeswarm()’

Examples:

       ggplot2::ggplot(ggplot2::mpg,aes(class, hwy)) + geom_quasirandom()
       # Generate fake data
       distro <- data.frame(
         'variable'=rep(c('runif','rnorm'),each=100),
         'value'=c(runif(100, min=-3, max=3), rnorm(100))
       )
       ggplot2::ggplot(distro,aes(variable, value)) + geom_quasirandom()
       ggplot2::ggplot(distro,aes(variable, value)) + geom_quasirandom(width=.1)
     

--------------------------------------------------------------------------------
Function: offset_beeswarm()
An internal function to calculate new positions for geom_beeswarm

Description:

     An internal function to calculate new positions for geom_beeswarm

Usage:

     offset_beeswarm(
       data,
       yLim.expand,
       xRange,
       yRange,
       method = "swarm",
       cex = 1,
       side = 0L,
       priority = "ascending",
       fast = TRUE,
       corral = "none",
       corral.width = 0.2,
       preserve.data.axis = FALSE
     )
     
Arguments:

    data: A data.frame containing plotting data in columns x and y.
          Usually obtained from data processed by ggplot2.

yLim.expand: y data limits plus a small expansion using
          ‘grDevices::extendrange’

  xRange: x axis scale range

  yRange: y axis scale range

  method: Method for arranging points (see Details below)

     cex: Scaling for adjusting point spacing (see
          ‘beeswarm::swarmx()’). Values between 1 (default) and 3 tend
          to work best.

    side: Direction to perform jittering: 0: both directions; 1: to the
          right or upwards; -1: to the left or downwards.

priority: Method used to perform point layout (see Details below)

    fast: Use compiled version of swarm algorithm? This option is
          ignored for all methods expect ‘"swarm"’ and
          ‘"compactswarm"’.

  corral: ‘string’. Method used to adjust points that would be placed
          to wide horizontally, default is ‘"none"’. See details below.

corral.width: ‘numeric’. Width of the corral, default is ‘0.9’.

preserve.data.axis: If TRUE, prevent ‘method’ from modifying the data
          axis (default FALSE). See Details for more info.

Details:

     *method:* specifies the algorithm used to avoid overlapping
     points. The default ‘"swarm"’ method places points in increasing
     order. If a point would overlap with an existing point, it is
     shifted sideways (along the group axis) by a minimal amount
     sufficient to avoid overlap.

     While the ‘"swarm"’ method places points in a predetermined order,
     the ‘"compactswarm"’ method uses a greedy strategy to determine
     which point will be placed next. This often leads to a more
     tightly-packed layout. The strategy is very simple: on each
     iteration, a point that can be placed as close as possible to the
     non-data axis is chosen and placed. If there are two or more
     equally good points, ‘priority’ is used to break ties.

     The other 3 methods first discretise the values along the data
     axis, in order to create more efficient packing. The ‘"square"’
     method places points on a square grid, whereas ‘"hex"’ uses a
     hexagonal grid. ‘"centre"’/‘"center"’ uses a square grid to
     produce a symmetric swarm. The number of break points for
     discretisation is determined by a combination of the available
     plotting area and the ‘cex’ argument.

     *priority:* controls the order in which points are placed, which
     generally has a noticeable effect on the plot appearance.
     ‘"ascending"’ gives the 'traditional' beeswarm plot.
     ‘"descending"’ is the opposite. ‘"density"’ prioritizes points
     with higher local density. ‘"random"’ places points in a random
     order. ‘"none"’ places points in the order provided.

     *corral:* By default, swarms from different groups are not
     prevented from overlapping, i.e. "corral = "none". Thus, datasets
     that are very large or unevenly distributed may produce ugly
     overlapping beeswarms. To control runaway points one can use the
     following methods. ‘"gutter"’ collects runaway points along the
     boundary between groups. ‘"wrap"’ implement periodic boundaries.
     ‘"random"’ places runaway points randomly in the region. ‘"omit"’
     omits runaway points.

     *preserve.data.axis:* In some cases, the underlying method may
     attempt to change the position of points along the ungrouped, or
     data, axis, in order to keep them from overlapping. To prevent
     this, set this option to TRUE.

See Also:

     ‘geom_beeswarm()’, ‘position_quasirandom()’, ‘beeswarm::swarmx()’

     Other position adjustments: ‘position_beeswarm()’,
     ‘position_quasirandom()’


--------------------------------------------------------------------------------
Function: position_beeswarm()
Arrange points using the \link[beeswarm] package.

Description:

     Arrange points using the \link[beeswarm] package.

Usage:

     position_beeswarm(
       method = "swarm",
       cex = 1,
       side = 0L,
       priority = "ascending",
       fast = TRUE,
       orientation = NULL,
       groupOnX = NULL,
       dodge.width = 0,
       corral = "none",
       corral.width = 0.2,
       preserve.data.axis = FALSE
     )
     
Arguments:

  method: Method for arranging points. Options are ‘"swarm"’ (default),
          ‘"compactswarm"’, ‘"square"’, ‘"hex"’, and ‘"center"’. See
          Details below.

     cex: Scaling for adjusting point spacing (see
          ‘beeswarm::swarmx()’). Values between 1 (default) and 3 tend
          to work best.

    side: Direction to perform jittering: 0: both directions; 1: to the
          right or upwards; -1: to the left or downwards.

priority: Method used to perform point layout. Options are
          ‘"ascending"’ (default), ‘"descending"’, ‘"density"’,
          ‘"random"’, or ‘"none"’. See Details below.

    fast: If ‘TRUE’ (default), use compiled version of swarm algorithm.
          This option is ignored for all methods except ‘"swarm"’ and
          ‘"compactswarm"’.

orientation: The orientation (i.e., which axis to group on) is inferred
          from the data. This can be overridden by setting
          ‘orientation’ to either ‘"x"’ or ‘"y"’.

groupOnX: *[Superseded]* See ‘orientation’.

dodge.width: Amount by which points from different aesthetic groups
          will be dodged. This requires that one of the aesthetics is a
          factor.

  corral: Method used to adjust points that would be placed too wide
          horizontally. Options are ‘"none"’ (default), ‘"gutter"’,
          ‘"wrap"’, ‘"random"’, and ‘"omit"’. See Details below.

corral.width: Width of the corral, if not ‘"none"’. Default is ‘0.9’.

preserve.data.axis: If TRUE, prevent ‘method’ from modifying the data
          axis (default FALSE). See Details for more info.

Details:

     *method:* specifies the algorithm used to avoid overlapping
     points. The default ‘"swarm"’ method places points in increasing
     order. If a point would overlap with an existing point, it is
     shifted sideways (along the group axis) by a minimal amount
     sufficient to avoid overlap.

     While the ‘"swarm"’ method places points in a predetermined order,
     the ‘"compactswarm"’ method uses a greedy strategy to determine
     which point will be placed next. This often leads to a more
     tightly-packed layout. The strategy is very simple: on each
     iteration, a point that can be placed as close as possible to the
     non-data axis is chosen and placed. If there are two or more
     equally good points, ‘priority’ is used to break ties.

     The other 3 methods first discretise the values along the data
     axis, in order to create more efficient packing. The ‘"square"’
     method places points on a square grid, whereas ‘"hex"’ uses a
     hexagonal grid. ‘"centre"’/‘"center"’ uses a square grid to
     produce a symmetric swarm. The number of break points for
     discretisation is determined by a combination of the available
     plotting area and the ‘cex’ argument.

     *priority:* controls the order in which points are placed, which
     generally has a noticeable effect on the plot appearance.
     ‘"ascending"’ gives the 'traditional' beeswarm plot.
     ‘"descending"’ is the opposite. ‘"density"’ prioritizes points
     with higher local density. ‘"random"’ places points in a random
     order. ‘"none"’ places points in the order provided.

     *corral:* By default, swarms from different groups are not
     prevented from overlapping, i.e. "corral = "none". Thus, datasets
     that are very large or unevenly distributed may produce ugly
     overlapping beeswarms. To control runaway points one can use the
     following methods. ‘"gutter"’ collects runaway points along the
     boundary between groups. ‘"wrap"’ implement periodic boundaries.
     ‘"random"’ places runaway points randomly in the region. ‘"omit"’
     omits runaway points.

     #' *preserve.data.axis:* In some cases, the underlying method may
     attempt to change the position of points along the ungrouped, or
     data, axis, in order to keep them from overlapping. To prevent
     this, set this option to TRUE.

See Also:

     ‘geom_beeswarm()’, ‘position_quasirandom()’, ‘beeswarm::swarmx()’

     Other position adjustments: ‘offset_beeswarm()’,
     ‘position_quasirandom()’


--------------------------------------------------------------------------------
Function: position_quasirandom()
Arrange points using quasirandom noise to avoid overplotting

Description:

     Arrange points using quasirandom noise to avoid overplotting

Usage:

     position_quasirandom(
       method = "quasirandom",
       width = NULL,
       varwidth = FALSE,
       bandwidth = 0.5,
       nbins = NULL,
       dodge.width = 0,
       orientation = NULL,
       groupOnX = NULL,
       na.rm = FALSE
     )
     
Arguments:

  method: Method used for distributing points. Options are
          ‘"quasirandom"’ (default), ‘"pseudorandom"’, ‘"smiley"’,
          ‘"maxout"’, ‘"frowney"’, ‘"minout"’, ‘"tukey"’,
          ‘"tukeyDense"’. See ‘vipor::offsetSingleGroup()’ for the
          details of each method.

   width: Maximum amount of spread (default: 0.4)

varwidth: Vary the width by the relative size of each group. (default:
          ‘FALSE’)

bandwidth: the bandwidth adjustment to use when calculating density
          Smaller numbers (< 1) produce a tighter "fit". (default: 0.5)

   nbins: the number of bins used when calculating density (has little
          effect with quasirandom/random distribution)

dodge.width: Amount by which points from different aesthetic groups
          will be dodged. This requires that one of the aesthetics is a
          factor. To disable dodging between groups, set this to NULL.
          (default: 0)

orientation: The orientation (i.e., which axis to group on) is inferred
          from the data. This can be overridden by setting
          ‘orientation’ to either ‘"x"’ or ‘"y"’.

groupOnX: *[Superseded]* See ‘orientation’.

   na.rm: if ‘FALSE’ (default), missing values are removed with a
          warning. If ‘TRUE’, missing values are silently removed.

See Also:

     ‘vipor::offsetSingleGroup()’, ‘geom_quasirandom()’

     Other position adjustments: ‘offset_beeswarm()’,
     ‘position_beeswarm()’



--------------------------------------------------------------------------------
Vignette: usageExamples.Rnw

\documentclass[article,nojss]{jss}


<<package,include=FALSE,echo=FALSE>>=
options(keep.source = TRUE, width = 60)
packageInfo <- packageDescription("ggbeeswarm")
library(ggbeeswarm)
packageKeywords<-"visualization, display, one dimensional, grouped, groups, violin, scatter, points, quasirandom, beeswarm, van der Corput, beeswarm, ggplot, ggplot2"
@
%\VignetteIndexEntry{ggbeeswarm package usage examples}
%\VignetteDepends{}
%\VignetteKeywords{visualization, display, one dimensional, grouped, groups, violin, scatter, points, quasirandom, beeswarm, van der Corput, beeswarm, ggplot, ggplot2}
%\VignettePackage{ggbeeswarm}

\title{\pkg{\Sexpr{packageInfo$Package}} package usage example (version \Sexpr{packageInfo$Version})}
\author{\Sexpr{packageInfo$Author}}
\Plainauthor{\Sexpr{packageInfo$Author}}
\Address{ Github: \url{http://github.com/eclarke/ggbeeswarm}\\
  Cran: \url{https://cran.r-project.org/package=ggbeeswarm}
}

\Keywords{\Sexpr{packageKeywords}}

\Abstract{
  This is a collection of examples of usage for the \pkg{\Sexpr{packageInfo$Package}} package.
}

\begin{document}
\SweaveOpts{concordance=TRUE}
\SweaveOpts{engine=R,eps=FALSE}

\section{The basics}

This is the simplest example of using \code{geom_quasirandom} to generate violin scatter plots:
<<ggPlot, echo=TRUE, eval=FALSE>>=
  library(ggbeeswarm)
  set.seed(12345)
  n<-100
  dat<-rnorm(n*2)
  labs<-rep(c('a','b'),n)
  ggplot(mapping=aes(labs, dat)) + geom_quasirandom()
@

\begin{center}
<<showGgPlot, fig=TRUE, height=3.5, width=5, echo=FALSE>>=
<<ggPlot>>
@
\end{center}


Normal \code{ggplot} options can be used:
<<ggOpts, echo=TRUE, eval=FALSE>>=
  ggplot(mapping=aes(labs, dat)) + geom_quasirandom(aes(color=labs))
@

\begin{center}
<<showGgOpts, fig=TRUE, height=3.5, width=5, echo=FALSE>>=
<<ggOpts>>
@
\end{center}

Factors can be used to generate custom group orderings:
<<ggFactors, echo=TRUE, eval=FALSE>>=
  labs2<-factor(labs,levels=c('b','a'))
  ggplot(mapping=aes(labs2, dat)) + geom_quasirandom(aes(color=labs))
@
\begin{center}
<<showGgFactors, fig=TRUE, height=3.5, width=5, echo=FALSE>>=
<<ggFactors>>
@
\end{center}

The axes can also be switched with a categorical y-axis:
<<yaxis, echo=TRUE, eval=FALSE>>=
  ggplot(mapping=aes(dat,labs)) + geom_quasirandom(aes(color=labs))
@
\begin{center}
<<showYaxis, fig=TRUE, height=3.5, width=5, echo=FALSE>>=
<<yaxis>>
@
\end{center}

And dodging can be used to compare within groups:
<<dodge, echo=TRUE, eval=FALSE>>=
  labs2<-factor(rep(1:2,each=n))
  ggplot(mapping=aes(labs,dat,color=labs2)) + geom_quasirandom(dodge.width=.8)
@
\begin{center}
<<showDodge, fig=TRUE, height=3.5, width=5, echo=FALSE>>=
<<dodge>>
@
\end{center}
Or on the y-axis:
<<dodgey, echo=TRUE, eval=FALSE>>=
  labs2<-factor(rep(1:2,each=n))
  ggplot(mapping=aes(dat,labs,color=labs2)) + geom_quasirandom(dodge.width=.8)
@
\begin{center}
<<showDodgey, fig=TRUE, height=3.5, width=5, echo=FALSE>>=
<<dodgey>>
@
\end{center}

And with \code{geom_beeswarm}:
<<dodgeBee, echo=TRUE, eval=FALSE>>= labs2<-factor(rep(1:2,each=n))
  ggplot(mapping=aes(labs,dat,color=labs2)) +
    geom_beeswarm(dodge.width=.8,cex=2)
@
\begin{center}
<<showDodgeBee, fig=TRUE, height=3.5, width=5, echo=FALSE>>=
<<dodgeBee>>
@
\end{center}
<<dodgeYBee, echo=TRUE, eval=FALSE>>=
  ggplot(mapping=aes(dat,labs,color=labs2)) +
    geom_beeswarm(dodge.width=.8,cex=2)
@
\begin{center}
<<showDodgeYBee, fig=TRUE, height=3.5, width=5, echo=FALSE>>=
<<dodgeYBee>>
@
\end{center}

Both \code{geom_beeswarm} and \code{geom_quasirandom} also work with facets:
<<facetQuasi, echo=TRUE, eval=FALSE>>= labs2<-factor(rep(1:2,each=n))
  df<-data.frame(labs,dat,labs2)
  ggplot(df,aes(labs,dat,color=labs2)) +
    geom_quasirandom() +
    facet_grid(.~labs2)
@
\begin{center}
<<showFacetQuasi, fig=TRUE, height=3.5, width=5, echo=FALSE>>=
<<facetQuasi>>
@
\end{center}
<<facetBee, echo=TRUE, eval=FALSE>>= labs2<-factor(rep(1:2,each=n))
  ggplot(df,aes(labs,dat,color=labs2)) +
    geom_beeswarm(cex=3) +
    facet_grid(.~labs2)
@
\begin{center}
<<showFacetBee, fig=TRUE, height=3.5, width=5, echo=FALSE>>=
<<facetBee>>
@
\end{center}






\section{Options}
There are several ways to plot grouped one-dimensional data combining points and density estimation including:
\begin{description}
	\item[pseudorandom] The kernel density is estimated then points are distributed uniform randomly within the density estimate for a given bin.  Selection of an appropriate number of bins does not greatly affect appearance but coincidental clumpiness is common.
	\item[alternating within bins] The kernel density is estimated then points are distributed within the density estimate for a given bin evenly spaced with extreme values alternating from right to left e.g. max, 3rd max, ..., 4th max, 2nd max. If maximums are placed on the outside then these plots often form consecutive ``smiley'' patterns. If minimums are placed on the outside then ``frowny'' patterns are generated. Selection of the number of bins can have large effects on appearance important.
	\item[tukey] An algorithm described by Tukey and Tukey in ``Strips displaying empirical distributions: I. textured dot strips'' using constrained permutations of offsets to distrbute the data.
	\item[quasirandom] The kernel density is estimated then points are distributed quasirandomly using the von der Corput sequence within the density estimate for a given bin.  Selection of an appropriate number of bins does not greatly affect appearance and position does not depend on plotting parameters.
	\item[beeswarm] The package \pkg{beeswarm} provides methods for generating a ``beeswarm'' plot where points are distibuted so that no points overlap. Kernel density is not calculated although the resulting plot does provide an approximate density estimate.  Selection of an appropriate number of bins affects appearance and plot and point sizes must be known in advance.
\end{description}

The first four options are included within \code{geom_quasirandom} using the \code{method=} argument and beeswarm plots are generated with \code{geom_beeswarm}:
<<methods, echo=TRUE, eval=FALSE, tidy=TRUE>>=
  library(gridExtra)
  dat <- list(
    'Normal'=rnorm(50),
    'Dense normal'= rnorm(500),
    'Bimodal'=c(rnorm(100), rnorm(100,5)),
    'Trimodal'=c(rnorm(100), rnorm(100,5),rnorm(100,-3))
  )
  labs<-rep(names(dat),sapply(dat,length))
  labs<-factor(labs,levels=unique(labs))
  dat<-unlist(dat)
  p1<-ggplot(mapping=aes(labs, dat)) +
    geom_quasirandom(alpha=.2) +
    ggtitle('quasirandom') + labs(x='') +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
  p2<-ggplot(mapping=aes(labs, dat)) +
    geom_quasirandom(method='pseudorandom',alpha=.2) +
    ggtitle('pseudorandom') + labs(x='') +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
  p3<-ggplot(mapping=aes(labs, dat)) +
    geom_quasirandom(method='smiley',alpha=.2) +
    ggtitle('smiley') + labs(x='') +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
  p4<-ggplot(mapping=aes(labs, dat)) +
    geom_quasirandom(method='frowney',alpha=.2) +
    ggtitle('frowney') + labs(x='') +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
  p5<-ggplot(mapping=aes(labs, dat)) +
    geom_quasirandom(method='tukey',alpha=.2) +
    ggtitle('tukey') + labs(x='') +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
  p6<-ggplot(mapping=aes(labs, dat)) +
    geom_beeswarm(alpha=.2,size=.75) +
    ggtitle('geom_beeswarm') + labs(x='') +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
  grid.arrange(p1, p2, p3, p4, p5, p6, ncol=3)
@
\begin{center}
<<showMethods, fig=TRUE, height=8, width=6.5, echo=FALSE>>=
<<methods>>
@
\end{center}


\code{quasirandom} calls \code{vipor::offsetX} which calls \code{stats::density} to compute kernel density estimates. The tightness of the fit can be adjusted with the \code{bandwidth} option and the width of the offset with \code{width}. \code{nbins} to adjust the number of bins used in the kernel density is also provided but this can usually be left at its default when using quasirandom offsets but is useful for non-quasirandom methods:

<<distAdjust, echo=TRUE, eval=FALSE, tidy=TRUE>>=
  library(gridExtra)
  p1<-ggplot(mapping=aes(labs, dat)) +
    geom_quasirandom(bandwidth=2,alpha=.2) +
    ggtitle('bandwidth=2') + labs(x='')
  p2<-ggplot(mapping=aes(labs, dat)) +
    geom_quasirandom(bandwidth=.1,alpha=.2) +
    ggtitle('bandwidth=.1') + labs(x='')
  p3<-ggplot(mapping=aes(labs, dat)) +
    geom_quasirandom(width=.1,alpha=.2) +
    ggtitle('width=.1') + labs(x='')
  p4<-ggplot(mapping=aes(labs, dat)) +
    geom_quasirandom(nbins=100,alpha=.2) +
    ggtitle('nbins=100') + labs(x='')
  grid.arrange(p1, p2, p3, p4, ncol=1)
@
\begin{center}
<<showDistAdjust, fig=TRUE, height=8, width=6, echo=FALSE>>=
<<distAdjust>>
@
\end{center}


The \code{frowney} or \code{smiley} methods are sensitive to the number of bins so the argument \code{nbins} is more useful/necessary with them:
<<nbins, echo=TRUE, eval=FALSE, tidy=TRUE>>=
  p1<-ggplot(mapping=aes(labs, dat)) +
    geom_quasirandom(method='smiley',alpha=.2) +
    ggtitle('Default (n/5)') + labs(x='')
  p2<-ggplot(mapping=aes(labs, dat)) +
    geom_quasirandom(method='smiley',nbins=50,alpha=.2) +
    ggtitle('nbins=50') + labs(x='')
  p3<-ggplot(mapping=aes(labs, dat)) +
    geom_quasirandom(method='smiley',nbins=100,alpha=.2) +
    ggtitle('nbins=100') + labs(x='')
  p4<-ggplot(mapping=aes(labs, dat)) +
    geom_quasirandom(method='smiley',nbins=250,alpha=.2) +
    ggtitle('nbins=250') + labs(x='')
  grid.arrange(p1, p2, p3, p4, ncol=1)
@
\begin{center}
<<showNBins, fig=TRUE, height=8, width=6, echo=FALSE>>=
<<nbins>>
@
\end{center}

The \code{varwidth} argument scales the width of a group by the square root of the number of observations in that group (as in the function \code{boxplot}):
<<varwidth, echo=TRUE, eval=FALSE>>=
  dat <- list(
    '10 points'=rnorm(10),
    '50 points'=rnorm(50,2),
    '200 points'=c(rnorm(400), rnorm(100,5)),
    '5000 points'= rnorm(5000,1)
  )
  labs<-rep(names(dat),sapply(dat,length))
  labs<-factor(labs,levels=unique(labs))
  dat<-unlist(dat)
  ggplot(mapping=aes(labs, dat)) + geom_quasirandom(alpha=.3,varwidth=TRUE)
@
\begin{center}
<<showVarwidth, fig=TRUE, height=4, width=6, echo=FALSE>>=
<<varwidth>>
@
\end{center}

\section{Real data}
An example using the \code{beaver1} and \code{beaver2} data from the \pkg{datasets} package:
<<vpBeaver, echo=TRUE, eval=FALSE>>=
  beaver<-data.frame(
    'Temperature'=c(beaver1$temp,beaver2$temp),
    'Beaver'=rep(
      c('Beaver 1','Beaver 2'),
      c(nrow(beaver1),nrow(beaver2))
    )
  )
  ggplot(beaver,mapping=aes(Beaver, Temperature)) + geom_quasirandom()
@
\begin{center}
<<showBeaver, fig=TRUE, height=4, width=4, echo=FALSE>>=
<<vpBeaver>>
@
\end{center}

An example using the \code{integrations} data from the \pkg{vipor} package and the argument \code{dodge.width}:
<<vpGene, echo=TRUE, eval=FALSE>>=
  library(vipor)
  ints<-integrations[integrations$nearestGene>0,]
  ints$logGeneDist<-log(ints$nearestGene)
  ggplot(ints,mapping=aes(study, logGeneDist,color=latent)) +
  geom_quasirandom(dodge.width=.9,alpha=.4)
@
\begin{center}
<<showGene, fig=TRUE, height=4, width=6, echo=FALSE>>=
<<vpGene>>
@
\end{center}


\end{document}




--------------------------------------------------------------------------------
Function: determine_pos()
function (v, method, side) 
{
    v.s <- lapply(split(v, v), seq_along)
    if (method %in% c("center", "square") && side == -1) 
        v.s <- lapply(v.s, function(a) a - max(a))
    else if (method %in% c("center", "square") && side == 1) 
        v.s <- lapply(v.s, function(a) a - 1)
    else if (method == "center") 
        v.s <- lapply(v.s, function(a) a - mean(a))
    else if (method == "square") 
        v.s <- lapply(v.s, function(a) a - floor(mean(a)))
    else if (method == "hex") {
        odd.row <- (as.numeric(names(v.s))%%2) == 1
        if (side == 0) {
            v.s[odd.row] <- lapply(v.s[odd.row], function(a) a - 
                floor(mean(a)) - 0.25)
            v.s[!odd.row] <- lapply(v.s[!odd.row], function(a) a - 
                ceiling(mean(a)) + 0.25)
        }
        else if (side == -1) {
            v.s[odd.row] <- lapply(v.s[odd.row], function(a) a - 
                max(a))
            v.s[!odd.row] <- lapply(v.s[!odd.row], function(a) a - 
                max(a) - 0.5)
        }
        else if (side == 1) {
            v.s[odd.row] <- lapply(v.s[odd.row], function(a) a - 
                1)
            v.s[!odd.row] <- lapply(v.s[!odd.row], function(a) a - 
                0.5)
        }
    }
    unsplit(v.s, v)
}

--------------------------------------------------------------------------------
Function: geom_beeswarm()
function (mapping = NULL, data = NULL, stat = "identity", ..., 
    method = "swarm", cex = 1, side = 0L, priority = "ascending", 
    fast = TRUE, dodge.width = NULL, corral = "none", corral.width = 0.9, 
    preserve.data.axis = FALSE, groupOnX = NULL, orientation = NULL, 
    beeswarmArgs = list(), na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) 
{
    if (!missing(groupOnX)) {
        lifecycle::deprecate_soft(when = "0.7.1", what = "position_beeswarm(groupOnX)", 
            details = "The axis to group on is now guessed from the data. To override, specify orientation=\"x\" or \"y\".")
        if (is.null(groupOnX) || !groupOnX) {
            orientation = "y"
        }
        else {
            orientation = "x"
        }
    }
    if (!missing(beeswarmArgs)) {
        lifecycle::deprecate_soft(when = "0.7.1", what = "geom_beeswarm(beeswarmArgs)")
    }
    if (!method %in% c("swarm", "compactswarm", "hex", "square", 
        "centre", "center")) {
        stop(sprintf("The method must be one of: swarm, compactswarm, hex, square, center, or centre."))
    }
    if (!corral %in% c("none", "gutter", "wrap", "random", "omit")) {
        stop(sprintf("The corral argument must be one of: none, gutter, wrap, random, or omit."))
    }
    position <- position_beeswarm(method = method, cex = cex, 
        side = side, priority = priority, fast = fast, dodge.width = dodge.width, 
        orientation = orientation, corral = corral, corral.width = corral.width, 
        preserve.data.axis = preserve.data.axis)
    layer(data = data, mapping = mapping, stat = stat, geom = GeomPoint, 
        position = position, show.legend = show.legend, inherit.aes = inherit.aes, 
        params = list(na.rm = na.rm, ...))
}

--------------------------------------------------------------------------------
Function: geom_quasirandom()
function (mapping = NULL, data = NULL, stat = "identity", ..., 
    method = "quasirandom", width = NULL, varwidth = FALSE, bandwidth = 0.5, 
    nbins = NULL, dodge.width = NULL, groupOnX = NULL, orientation = NULL, 
    na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) 
{
    position <- position_quasirandom(method = method, width = width, 
        varwidth = varwidth, bandwidth = bandwidth, nbins = nbins, 
        dodge.width = dodge.width, orientation = orientation, 
        na.rm = na.rm)
    ggplot2::layer(data = data, mapping = mapping, stat = stat, 
        geom = GeomPoint, position = position, show.legend = show.legend, 
        inherit.aes = inherit.aes, params = list(na.rm = na.rm, 
            ...))
}

--------------------------------------------------------------------------------
Function: get_range()
function (scales) 
{
    if (is.null(scales$limits)) 
        lim <- scales$range$range
    else lim <- scales$get_limits()
    if (inherits(scales, "ScaleContinuous")) {
        out <- diff(lim)
    }
    else if (inherits(scales, "ScaleDiscrete")) {
        out <- length(unique(lim))
    }
    else {
        stop("Unknown scale type")
    }
    if (out == 0) 
        out <- 1
    out
}

--------------------------------------------------------------------------------
Function: offset_beeswarm()
function (data, yLim.expand, xRange, yRange, method = "swarm", 
    cex = 1, side = 0L, priority = "ascending", fast = TRUE, 
    corral = "none", corral.width = 0.2, preserve.data.axis = FALSE) 
{
    if (method %in% c("swarm", "compactswarm")) {
        x.size <- xRange/100
        y.size <- yRange/100
        compact <- method == "compactswarm"
        x.offset <- beeswarm::swarmx(x = rep(0, length(data$y)), 
            y = data$y, xsize = x.size, ysize = y.size, cex = cex, 
            side = side, priority = priority, fast = fast, compact = compact)$x
    }
    else {
        x.size <- xRange/100 * cex
        y.size <- yRange/100 * cex
        if (method == "hex") 
            y.size <- y.size * sqrt(3)/2
        breaks <- seq(yLim.expand[1], yLim.expand[2] + y.size, 
            by = y.size)
        mids <- (utils::head(breaks, -1) + utils::tail(breaks, 
            -1))/2
        y.index <- sapply(data$y, cut, breaks = breaks, include.lowest = T, 
            labels = FALSE)
        y.pos <- sapply(y.index, function(a) mids[a])
        if (any(data$y != y.pos) && !preserve.data.axis) {
            cli::cli_warn(c("In `position_beeswarm`, method `{method}` discretizes the data axis (a.k.a the continuous or non-grouped axis).", 
                "This may result in changes to the position of the points along that axis, proportional to the value of `cex`.", 
                "To prevent this behavior, set `preserve.data.axis=TRUE`."), 
                .frequency = "once", .frequency_id = "beeswarm_method_data_axis_warn")
        }
        if (!preserve.data.axis) {
            data$y <- y.pos
        }
        x.index <- determine_pos(y.index, method, side)
        x.offset <- x.index * x.size
    }
    if (corral != "none") {
        corral.low <- (side - 1) * corral.width/2
        corral.high <- (side + 1) * corral.width/2
        if (corral == "gutter") {
            x.offset <- sapply(x.offset, function(zz) pmin(corral.high, 
                pmax(corral.low, zz)))
        }
        if (corral == "wrap") {
            if (side == -1L) {
                x.offset <- sapply(x.offset, function(zz) corral.high - 
                  ((corral.high - zz)%%corral.width))
            }
            else {
                x.offset <- sapply(x.offset, function(zz) ((zz - 
                  corral.low)%%corral.width) + corral.low)
            }
        }
        if (corral == "random") {
            x.offset <- sapply(x.offset, function(zz) ifelse(zz > 
                corral.high | zz < corral.low, yes = stats::runif(length(zz), 
                corral.low, corral.high), no = zz))
        }
        if (corral == "omit") {
            x.offset <- sapply(x.offset, function(zz) ifelse(zz > 
                corral.high | zz < corral.low, yes = NA, no = zz))
        }
    }
    data$x <- data$x + x.offset
    return(data)
}

--------------------------------------------------------------------------------
Function: offset_quasirandom()
function (data, width = 0.4, vary.width = FALSE, max.length = NULL, 
    ...) 
{
    x.offset <- vipor::aveWithArgs(data$y, data$x, FUN = vipor::offsetSingleGroup, 
        maxLength = if (vary.width) {
            max.length
        }
        else {
            NULL
        }, ...)
    x.offset <- x.offset * width
    data$x <- data$x + x.offset
    if ("xend" %in% colnames(data) && "yend" %in% colnames(data)) {
        x.offset <- vipor::aveWithArgs(data$yend, data$xend, 
            FUN = vipor::offsetSingleGroup, maxLength = if (vary.width) {
                max.length
            }
            else {
                NULL
            }, ...)
        x.offset <- x.offset * width
        data$xend <- data$xend + x.offset
    }
    data
}

--------------------------------------------------------------------------------
Function: position_beeswarm()
function (method = "swarm", cex = 1, side = 0L, priority = "ascending", 
    fast = TRUE, orientation = NULL, groupOnX = NULL, dodge.width = 0, 
    corral = "none", corral.width = 0.2, preserve.data.axis = FALSE) 
{
    if (!missing(groupOnX)) {
        lifecycle::deprecate_soft(when = "0.7.1", what = "position_beeswarm(groupOnX)", 
            details = "The axis to group on is now guessed from the data. To override, specify orientation=\"x\" or \"y\".")
        if (is.null(groupOnX) || !groupOnX) {
            orientation = "y"
        }
        else {
            orientation = "x"
        }
    }
    if (!is.null(orientation) && !(orientation %in% c("x", "y"))) {
        cli::cli_abort("{.fn orientation} must be 'x', 'y', or NULL.")
    }
    if (method == "centre") 
        method <- "center"
    ggproto(NULL, PositionBeeswarm, method = method, cex = cex, 
        side = side, priority = priority, fast = fast, orientation = orientation, 
        dodge.width = dodge.width, corral = corral, corral.width = corral.width, 
        preserve.data.axis = preserve.data.axis)
}

--------------------------------------------------------------------------------
Function: position_quasirandom()
function (method = "quasirandom", width = NULL, varwidth = FALSE, 
    bandwidth = 0.5, nbins = NULL, dodge.width = 0, orientation = NULL, 
    groupOnX = NULL, na.rm = FALSE) 
{
    if (!missing(groupOnX)) {
        lifecycle::deprecate_soft(when = "0.7.1", what = "position_quasirandom(groupOnX)", 
            details = "The axis to group on is now guessed from the data. To override, specify orientation=\"x\" or \"y\".")
        if (groupOnX) {
            orientation = "x"
        }
        else {
            orientation = "y"
        }
    }
    if (!method %in% c("quasirandom", "pseudorandom", "smiley", 
        "maxout", "frowney", "minout", "tukey", "tukeyDense")) {
        cli::cli_abort("{.fn method} must be one of: quasirandom, pseudorandom, smiley, maxout, frowney, minout, tukey, or tukeyDense.")
    }
    if (!is.null(orientation) && !(orientation %in% c("x", "y"))) {
        cli::cli_abort("{.fn orientation} must be 'x', 'y', or NULL.")
    }
    ggproto(NULL, PositionQuasirandom, width = width, varwidth = varwidth, 
        bandwidth = bandwidth, nbins = nbins, method = method, 
        dodge.width = dodge.width, na.rm = na.rm, orientation = orientation)
}
